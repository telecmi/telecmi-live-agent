"use strict"; !function ( a, b ) { "object" == typeof exports && "undefined" != typeof module ? module.exports = b() : "function" == typeof define && define.amd ? define( b ) : ( a = "undefined" != typeof globalThis ? globalThis : a || self, a.io = b() ) }( this, function () {
    function a ( b ) { "@babel/helpers - typeof"; return ( a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function ( a ) { return typeof a } : function ( a ) { return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : typeof a } )( b ) } function b ( a, b ) { if ( !( a instanceof b ) ) throw new TypeError( "Cannot call a class as a function" ) } function c ( a, b ) { for ( var c = 0; c < b.length; c++ ) { var d = b[c]; d.enumerable = d.enumerable || !1, d.configurable = !0, "value" in d && ( d.writable = !0 ), Object.defineProperty( a, d.key, d ) } } function d ( a, b, d ) { return b && c( a.prototype, b ), d && c( a, d ), a } function e () { return e = Object.assign || function ( a ) { for ( var b = 1; b < arguments.length; b++ ) { var c = arguments[b]; for ( var d in c ) Object.prototype.hasOwnProperty.call( c, d ) && ( a[d] = c[d] ) } return a }, e.apply( this, arguments ) } function f ( a, b ) { if ( "function" != typeof b && null !== b ) throw new TypeError( "Super expression must either be null or a function" ); a.prototype = Object.create( b && b.prototype, { constructor: { value: a, writable: !0, configurable: !0 } } ), b && h( a, b ) } function g ( a ) { return ( g = Object.setPrototypeOf ? Object.getPrototypeOf : function ( a ) { return a.__proto__ || Object.getPrototypeOf( a ) } )( a ) } function h ( a, b ) { return ( h = Object.setPrototypeOf || function ( a, b ) { return a.__proto__ = b, a } )( a, b ) } function i () { if ( "undefined" == typeof Reflect || !Reflect.construct ) return !1; if ( Reflect.construct.sham ) return !1; if ( "function" == typeof Proxy ) return !0; try { return Boolean.prototype.valueOf.call( Reflect.construct( Boolean, [], function () { } ) ), !0 } catch ( a ) { return !1 } } function j ( a ) { if ( void 0 === a ) throw new ReferenceError( "this hasn't been initialised - super() hasn't been called" ); return a } function k ( a, b ) { if ( b && ( "object" == typeof b || "function" == typeof b ) ) return b; if ( void 0 !== b ) throw new TypeError( "Derived constructors may only return object or undefined" ); return j( a ) } function l ( a ) { var b = i(); return function () { var c, d = g( a ); if ( b ) { var e = g( this ).constructor; c = Reflect.construct( d, arguments, e ) } else c = d.apply( this, arguments ); return k( this, c ) } } function m ( a, b ) { for ( ; !Object.prototype.hasOwnProperty.call( a, b ) && ( a = g( a ), null !== a ); ); return a } function n ( a, b, c ) { return ( n = "undefined" != typeof Reflect && Reflect.get ? Reflect.get : function ( a, b, c ) { var d = m( a, b ); if ( d ) { var e = Object.getOwnPropertyDescriptor( d, b ); return e.get ? e.get.call( c ) : e.value } } )( a, b, c || a ) } function o ( a, b ) { if ( a ) { if ( "string" == typeof a ) return p( a, b ); var c = Object.prototype.toString.call( a ).slice( 8, -1 ); return "Object" === c && a.constructor && ( c = a.constructor.name ), "Map" === c || "Set" === c ? Array.from( a ) : "Arguments" === c || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test( c ) ? p( a, b ) : void 0 } } function p ( a, b ) { ( null == b || b > a.length ) && ( b = a.length ); for ( var c = 0, d = new Array( b ); b > c; c++ )d[c] = a[c]; return d } function q ( a, b ) { var c = "undefined" != typeof Symbol && a[Symbol.iterator] || a["@@iterator"]; if ( !c ) { if ( Array.isArray( a ) || ( c = o( a ) ) || b && a && "number" == typeof a.length ) { c && ( a = c ); var d = 0, e = function () { }; return { s: e, n: function () { return d >= a.length ? { done: !0 } : { done: !1, value: a[d++] } }, e: function ( a ) { throw a }, f: e } } throw new TypeError( "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method." ) } var f, g = !0, h = !1; return { s: function () { c = c.call( a ) }, n: function () { var a = c.next(); return g = a.done, a }, e: function ( a ) { h = !0, f = a }, f: function () { try { g || null == c["return"] || c["return"]() } finally { if ( h ) throw f } } } } function r ( a, b ) { var c = /\/{2,9}/g, d = b.replace( c, "/" ).split( "/" ); return ( "/" == b.substr( 0, 1 ) || 0 === b.length ) && d.splice( 0, 1 ), "/" == b.substr( b.length - 1, 1 ) && d.splice( d.length - 1, 1 ), d } function s ( a, b ) { var c = {}; return b.replace( /(?:^|&)([^&=]*)=?([^&]*)/g, function ( a, b, d ) { b && ( c[b] = d ) } ), c } function t ( a ) { var b = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "", c = arguments.length > 2 ? arguments[2] : void 0, d = a; c = c || "undefined" != typeof location && location, null == a && ( a = c.protocol + "//" + c.host ), "string" == typeof a && ( "/" === a.charAt( 0 ) && ( a = "/" === a.charAt( 1 ) ? c.protocol + a : c.host + a ), /^(https?|wss?):\/\//.test( a ) || ( a = "undefined" != typeof c ? c.protocol + "//" + a : "https://" + a ), d = R( a ) ), d.port || ( /^(http|ws)$/.test( d.protocol ) ? d.port = "80" : /^(http|ws)s$/.test( d.protocol ) && ( d.port = "443" ) ), d.path = d.path || "/"; var e = -1 !== d.host.indexOf( ":" ), f = e ? "[" + d.host + "]" : d.host; return d.id = d.protocol + "://" + f + ":" + d.port + b, d.href = d.protocol + "://" + f + ( c && c.port === d.port ? "" : ":" + d.port ), d } function u ( a ) { var b = a.xdomain; try { if ( "undefined" != typeof XMLHttpRequest && ( !b || U ) ) return new XMLHttpRequest } catch ( c ) { } if ( !b ) try { return new ( V[["Active"].concat( "Object" ).join( "X" )] )( "Microsoft.XMLHTTP" ) } catch ( c ) { } } function v ( a ) { for ( var b = arguments.length, c = new Array( b > 1 ? b - 1 : 0 ), d = 1; b > d; d++ )c[d - 1] = arguments[d]; return c.reduce( function ( b, c ) { return a.hasOwnProperty( c ) && ( b[c] = a[c] ), b }, {} ) } function w ( a, b ) { b.useNativeTimers ? ( a.setTimeoutFn = W.bind( V ), a.clearTimeoutFn = X.bind( V ) ) : ( a.setTimeoutFn = setTimeout.bind( V ), a.clearTimeoutFn = clearTimeout.bind( V ) ) } function x ( a ) { return a ? y( a ) : void 0 } function y ( a ) { for ( var b in x.prototype ) a[b] = x.prototype[b]; return a } function z ( a ) { var b = ""; do b = ta[a % ua] + b, a = Math.floor( a / ua ); while ( a > 0 ); return b } function A ( a ) { var b = 0; for ( xa = 0; xa < a.length; xa++ )b = b * ua + va[a.charAt( xa )]; return b } function B () { var a = z( +new Date ); return a !== ia ? ( wa = 0, ia = a ) : a + "." + z( wa++ ) } function C () { } function D () { for ( var a in Da.requests ) Da.requests.hasOwnProperty( a ) && Da.requests[a].abort() } function E ( a ) { var b = {}; for ( var c in a ) a.hasOwnProperty( c ) && ( b[c] = a[c] ); return b } function F ( a ) { return Oa && ( a instanceof ArrayBuffer || Pa( a ) ) || Ra && a instanceof Blob || Sa && a instanceof File } function G ( b, c ) { if ( !b || "object" !== a( b ) ) return !1; if ( Array.isArray( b ) ) { for ( var d = 0, e = b.length; e > d; d++ )if ( G( b[d] ) ) return !0; return !1 } if ( F( b ) ) return !0; if ( b.toJSON && "function" == typeof b.toJSON && 1 === arguments.length ) return G( b.toJSON(), !0 ); for ( var f in b ) if ( Object.prototype.hasOwnProperty.call( b, f ) && G( b[f] ) ) return !0; return !1 } function H ( a ) { var b = [], c = a.data, d = a; return d.data = I( c, b ), d.attachments = b.length, { packet: d, buffers: b } } function I ( b, c ) { if ( !b ) return b; if ( F( b ) ) { var d = { _placeholder: !0, num: c.length }; return c.push( b ), d } if ( Array.isArray( b ) ) { for ( var e = new Array( b.length ), f = 0; f < b.length; f++ )e[f] = I( b[f], c ); return e } if ( "object" === a( b ) && !( b instanceof Date ) ) { var g = {}; for ( var h in b ) b.hasOwnProperty( h ) && ( g[h] = I( b[h], c ) ); return g } return b } function J ( a, b ) { return a.data = K( a.data, b ), a.attachments = void 0, a } function K ( b, c ) { if ( !b ) return b; if ( b && b._placeholder ) return c[b.num]; if ( Array.isArray( b ) ) for ( var d = 0; d < b.length; d++ )b[d] = K( b[d], c ); else if ( "object" === a( b ) ) for ( var e in b ) b.hasOwnProperty( e ) && ( b[e] = K( b[e], c ) ); return b } function L ( a ) { try { return JSON.parse( a ) } catch ( b ) { return !1 } } function M ( a, b, c ) { return a.on( b, c ), function () { a.off( b, c ) } } function N ( a ) { a = a || {}, this.ms = a.min || 100, this.max = a.max || 1e4, this.factor = a.factor || 2, this.jitter = a.jitter > 0 && a.jitter <= 1 ? a.jitter : 0, this.attempts = 0 } function O ( b, c ) { "object" === a( b ) && ( c = b, b = void 0 ), c = c || {}; var d, e = t( b, c.path || "/socket.io" ), f = e.source, g = e.id, h = e.path, i = ab[g] && h in ab[g].nsps, j = c.forceNew || c["force new connection"] || !1 === c.multiplex || i; return j ? d = new _a( f, c ) : ( ab[g] || ( ab[g] = new _a( f, c ) ), d = ab[g] ), e.query && !c.query && ( c.query = e.queryKey ), d.socket( e.path, c ) } var P = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, Q = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"], R = function ( a ) { var b = a, c = a.indexOf( "[" ), d = a.indexOf( "]" ); -1 != c && -1 != d && ( a = a.substring( 0, c ) + a.substring( c, d ).replace( /:/g, ";" ) + a.substring( d, a.length ) ); for ( var e = P.exec( a || "" ), f = {}, g = 14; g--; )f[Q[g]] = e[g] || ""; return -1 != c && -1 != d && ( f.source = b, f.host = f.host.substring( 1, f.host.length - 1 ).replace( /;/g, ":" ), f.authority = f.authority.replace( "[", "" ).replace( "]", "" ).replace( /;/g, ":" ), f.ipv6uri = !0 ), f.pathNames = r( f, f.path ), f.queryKey = s( f, f.query ), f }, S = { exports: {} }; try { S.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest } catch ( T ) { S.exports = !1 } var U = S.exports, V = function () { return "undefined" != typeof self ? self : "undefined" != typeof window ? window : Function( "return this" )() }(), W = setTimeout, X = clearTimeout, Y = x; x.prototype.on = x.prototype.addEventListener = function ( a, b ) { return this._callbacks = this._callbacks || {}, ( this._callbacks["$" + a] = this._callbacks["$" + a] || [] ).push( b ), this }, x.prototype.once = function ( a, b ) { function c () { this.off( a, c ), b.apply( this, arguments ) } return c.fn = b, this.on( a, c ), this }, x.prototype.off = x.prototype.removeListener = x.prototype.removeAllListeners = x.prototype.removeEventListener = function ( a, b ) { if ( this._callbacks = this._callbacks || {}, 0 == arguments.length ) return this._callbacks = {}, this; var c = this._callbacks["$" + a]; if ( !c ) return this; if ( 1 == arguments.length ) return delete this._callbacks["$" + a], this; for ( var d, e = 0; e < c.length; e++ )if ( d = c[e], d === b || d.fn === b ) { c.splice( e, 1 ); break } return 0 === c.length && delete this._callbacks["$" + a], this }, x.prototype.emit = function ( a ) { this._callbacks = this._callbacks || {}; for ( var b = new Array( arguments.length - 1 ), c = this._callbacks["$" + a], d = 1; d < arguments.length; d++ )b[d - 1] = arguments[d]; if ( c ) { c = c.slice( 0 ); for ( var d = 0, e = c.length; e > d; ++d )c[d].apply( this, b ) } return this }, x.prototype.emitReserved = x.prototype.emit, x.prototype.listeners = function ( a ) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + a] || [] }, x.prototype.hasListeners = function ( a ) { return !!this.listeners( a ).length }; var Z = Object.create( null ); Z.open = "0", Z.close = "1", Z.ping = "2", Z.pong = "3", Z.message = "4", Z.upgrade = "5", Z.noop = "6"; var $ = Object.create( null ); Object.keys( Z ).forEach( function ( a ) { $[Z[a]] = a } ); for ( var _ = { type: "error", data: "parser error" }, aa = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === Object.prototype.toString.call( Blob ), ba = "function" == typeof ArrayBuffer, ca = function ( a ) { return "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView( a ) : a && a.buffer instanceof ArrayBuffer }, da = function ( a, b, c ) { var d = a.type, e = a.data; return aa && e instanceof Blob ? b ? c( e ) : ea( e, c ) : ba && ( e instanceof ArrayBuffer || ca( e ) ) ? b ? c( e ) : ea( new Blob( [e] ), c ) : c( Z[d] + ( e || "" ) ) }, ea = function ( a, b ) { var c = new FileReader; return c.onload = function () { var a = c.result.split( "," )[1]; b( "b" + a ) }, c.readAsDataURL( a ) }, fa = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", ga = "undefined" == typeof Uint8Array ? [] : new Uint8Array( 256 ), ha = 0; ha < fa.length; ha++ )ga[fa.charCodeAt( ha )] = ha; for ( var ia, ja = function ( a ) { var b, c, d, e, f, g = .75 * a.length, h = a.length, i = 0; "=" === a[a.length - 1] && ( g--, "=" === a[a.length - 2] && g-- ); var j = new ArrayBuffer( g ), k = new Uint8Array( j ); for ( b = 0; h > b; b += 4 )c = ga[a.charCodeAt( b )], d = ga[a.charCodeAt( b + 1 )], e = ga[a.charCodeAt( b + 2 )], f = ga[a.charCodeAt( b + 3 )], k[i++] = c << 2 | d >> 4, k[i++] = ( 15 & d ) << 4 | e >> 2, k[i++] = ( 3 & e ) << 6 | 63 & f; return j }, ka = "function" == typeof ArrayBuffer, la = function ( a, b ) { if ( "string" != typeof a ) return { type: "message", data: na( a, b ) }; var c = a.charAt( 0 ); if ( "b" === c ) return { type: "message", data: ma( a.substring( 1 ), b ) }; var d = $[c]; return d ? a.length > 1 ? { type: $[c], data: a.substring( 1 ) } : { type: $[c] } : _ }, ma = function ( a, b ) { if ( ka ) { var c = ja( a ); return na( c, b ) } return { base64: !0, data: a } }, na = function ( a, b ) { switch ( b ) { case "blob": return a instanceof ArrayBuffer ? new Blob( [a] ) : a; case "arraybuffer": default: return a } }, oa = String.fromCharCode( 30 ), pa = function ( a, b ) { var c = a.length, d = new Array( c ), e = 0; a.forEach( function ( a, f ) { da( a, !1, function ( a ) { d[f] = a, ++e === c && b( d.join( oa ) ) } ) } ) }, qa = function ( a, b ) { for ( var c = a.split( oa ), d = [], e = 0; e < c.length; e++ ) { var f = la( c[e], b ); if ( d.push( f ), "error" === f.type ) break } return d }, ra = 4, sa = function ( a ) { function c ( a ) { var d; return b( this, c ), d = e.call( this ), d.writable = !1, w( j( d ), a ), d.opts = a, d.query = a.query, d.readyState = "", d.socket = a.socket, d } f( c, a ); var e = l( c ); return d( c, [{ key: "onError", value: function ( a, b ) { var d = new Error( a ); return d.type = "TransportError", d.description = b, n( g( c.prototype ), "emit", this ).call( this, "error", d ), this } }, { key: "open", value: function () { return ( "closed" === this.readyState || "" === this.readyState ) && ( this.readyState = "opening", this.doOpen() ), this } }, { key: "close", value: function () { return ( "opening" === this.readyState || "open" === this.readyState ) && ( this.doClose(), this.onClose() ), this } }, { key: "send", value: function ( a ) { "open" === this.readyState && this.write( a ) } }, { key: "onOpen", value: function () { this.readyState = "open", this.writable = !0, n( g( c.prototype ), "emit", this ).call( this, "open" ) } }, { key: "onData", value: function ( a ) { var b = la( a, this.socket.binaryType ); this.onPacket( b ) } }, { key: "onPacket", value: function ( a ) { n( g( c.prototype ), "emit", this ).call( this, "packet", a ) } }, { key: "onClose", value: function () { this.readyState = "closed", n( g( c.prototype ), "emit", this ).call( this, "close" ) } }] ), c }( Y ), ta = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split( "" ), ua = 64, va = {}, wa = 0, xa = 0; ua > xa; xa++ )va[ta[xa]] = xa; B.encode = z, B.decode = A; var ya = B, za = {}; za.encode = function ( a ) { var b = ""; for ( var c in a ) a.hasOwnProperty( c ) && ( b.length && ( b += "&" ), b += encodeURIComponent( c ) + "=" + encodeURIComponent( a[c] ) ); return b }, za.decode = function ( a ) { for ( var b = {}, c = a.split( "&" ), d = 0, e = c.length; e > d; d++ ) { var f = c[d].split( "=" ); b[decodeURIComponent( f[0] )] = decodeURIComponent( f[1] ) } return b }; var Aa = function ( a ) { function c () { var a; return b( this, c ), a = e.apply( this, arguments ), a.polling = !1, a } f( c, a ); var e = l( c ); return d( c, [{ key: "name", get: function () { return "polling" } }, { key: "doOpen", value: function () { this.poll() } }, { key: "pause", value: function g ( a ) { var b = this; this.readyState = "pausing"; var g = function () { b.readyState = "paused", a() }; if ( this.polling || !this.writable ) { var c = 0; this.polling && ( c++, this.once( "pollComplete", function () { --c || g() } ) ), this.writable || ( c++, this.once( "drain", function () { --c || g() } ) ) } else g() } }, { key: "poll", value: function () { this.polling = !0, this.doPoll(), this.emit( "poll" ) } }, { key: "onData", value: function ( a ) { var b = this, c = function ( a ) { return "opening" === b.readyState && "open" === a.type && b.onOpen(), "close" === a.type ? ( b.onClose(), !1 ) : void b.onPacket( a ) }; qa( a, this.socket.binaryType ).forEach( c ), "closed" !== this.readyState && ( this.polling = !1, this.emit( "pollComplete" ), "open" === this.readyState && this.poll() ) } }, { key: "doClose", value: function () { var a = this, b = function () { a.write( [{ type: "close" }] ) }; "open" === this.readyState ? b() : this.once( "open", b ) } }, { key: "write", value: function ( a ) { var b = this; this.writable = !1, pa( a, function ( a ) { b.doWrite( a, function () { b.writable = !0, b.emit( "drain" ) } ) } ) } }, { key: "uri", value: function () { var a = this.query || {}, b = this.opts.secure ? "https" : "http", c = ""; !1 !== this.opts.timestampRequests && ( a[this.opts.timestampParam] = ya() ), this.supportsBinary || a.sid || ( a.b64 = 1 ), this.opts.port && ( "https" === b && 443 !== Number( this.opts.port ) || "http" === b && 80 !== Number( this.opts.port ) ) && ( c = ":" + this.opts.port ); var d = za.encode( a ), e = -1 !== this.opts.hostname.indexOf( ":" ); return b + "://" + ( e ? "[" + this.opts.hostname + "]" : this.opts.hostname ) + c + this.opts.path + ( d.length ? "?" + d : "" ) } }] ), c }( sa ), Ba = function () { var a = new u( { xdomain: !1 } ); return null != a.responseType }(), Ca = function ( a ) { function c ( a ) { var d; if ( b( this, c ), d = g.call( this, a ), "undefined" != typeof location ) { var e = "https:" === location.protocol, f = location.port; f || ( f = e ? "443" : "80" ), d.xd = "undefined" != typeof location && a.hostname !== location.hostname || f !== a.port, d.xs = a.secure !== e } var h = a && a.forceBase64; return d.supportsBinary = Ba && !h, d } f( c, a ); var g = l( c ); return d( c, [{ key: "request", value: function () { var a = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}; return e( a, { xd: this.xd, xs: this.xs }, this.opts ), new Da( this.uri(), a ) } }, { key: "doWrite", value: function ( a, b ) { var c = this, d = this.request( { method: "POST", data: a } ); d.on( "success", b ), d.on( "error", function ( a ) { c.onError( "xhr post error", a ) } ) } }, { key: "doPoll", value: function () { var a = this, b = this.request(); b.on( "data", this.onData.bind( this ) ), b.on( "error", function ( b ) { a.onError( "xhr poll error", b ) } ), this.pollXhr = b } }] ), c }( Aa ), Da = function ( a ) { function c ( a, d ) { var f; return b( this, c ), f = e.call( this ), w( j( f ), d ), f.opts = d, f.method = d.method || "GET", f.uri = a, f.async = !1 !== d.async, f.data = void 0 !== d.data ? d.data : null, f.create(), f } f( c, a ); var e = l( c ); return d( c, [{ key: "create", value: function () { var a = this, b = v( this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref" ); b.xdomain = !!this.opts.xd, b.xscheme = !!this.opts.xs; var d = this.xhr = new u( b ); try { d.open( this.method, this.uri, this.async ); try { if ( this.opts.extraHeaders ) { d.setDisableHeaderCheck && d.setDisableHeaderCheck( !0 ); for ( var e in this.opts.extraHeaders ) this.opts.extraHeaders.hasOwnProperty( e ) && d.setRequestHeader( e, this.opts.extraHeaders[e] ) } } catch ( f ) { } if ( "POST" === this.method ) try { d.setRequestHeader( "Content-type", "text/plain;charset=UTF-8" ) } catch ( f ) { } try { d.setRequestHeader( "Accept", "*/*" ) } catch ( f ) { } "withCredentials" in d && ( d.withCredentials = this.opts.withCredentials ), this.opts.requestTimeout && ( d.timeout = this.opts.requestTimeout ), d.onreadystatechange = function () { 4 === d.readyState && ( 200 === d.status || 1223 === d.status ? a.onLoad() : a.setTimeoutFn( function () { a.onError( "number" == typeof d.status ? d.status : 0 ) }, 0 ) ) }, d.send( this.data ) } catch ( f ) { return void this.setTimeoutFn( function () { a.onError( f ) }, 0 ) } "undefined" != typeof document && ( this.index = c.requestsCount++, c.requests[this.index] = this ) } }, { key: "onSuccess", value: function () { this.emit( "success" ), this.cleanup() } }, { key: "onData", value: function ( a ) { this.emit( "data", a ), this.onSuccess() } }, { key: "onError", value: function ( a ) { this.emit( "error", a ), this.cleanup( !0 ) } }, { key: "cleanup", value: function ( a ) { if ( "undefined" != typeof this.xhr && null !== this.xhr ) { if ( this.xhr.onreadystatechange = C, a ) try { this.xhr.abort() } catch ( b ) { } "undefined" != typeof document && delete c.requests[this.index], this.xhr = null } } }, { key: "onLoad", value: function () { var a = this.xhr.responseText; null !== a && this.onData( a ) } }, { key: "abort", value: function () { this.cleanup() } }] ), c }( Y ); if ( Da.requestsCount = 0, Da.requests = {}, "undefined" != typeof document ) if ( "function" == typeof attachEvent ) attachEvent( "onunload", D ); else if ( "function" == typeof addEventListener ) { var Ea = "onpagehide" in V ? "pagehide" : "unload"; addEventListener( Ea, D, !1 ) } var Fa = function () { var a = "function" == typeof Promise && "function" == typeof Promise.resolve; return a ? function ( a ) { return Promise.resolve().then( a ) } : function ( a, b ) { return b( a, 0 ) } }(), Ga = V.WebSocket || V.MozWebSocket, Ha = !0, Ia = "arraybuffer", Ja = "undefined" != typeof navigator && "string" == typeof navigator.product && "reactnative" === navigator.product.toLowerCase(), Ka = function ( a ) { function c ( a ) { var d; return b( this, c ), d = e.call( this, a ), d.supportsBinary = !a.forceBase64, d } f( c, a ); var e = l( c ); return d( c, [{ key: "name", get: function () { return "websocket" } }, { key: "doOpen", value: function () { if ( this.check() ) { var a = this.uri(), b = this.opts.protocols, c = Ja ? {} : v( this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity" ); this.opts.extraHeaders && ( c.headers = this.opts.extraHeaders ); try { this.ws = Ha && !Ja ? b ? new Ga( a, b ) : new Ga( a ) : new Ga( a, b, c ) } catch ( d ) { return this.emit( "error", d ) } this.ws.binaryType = this.socket.binaryType || Ia, this.addEventListeners() } } }, { key: "addEventListeners", value: function () { var a = this; this.ws.onopen = function () { a.opts.autoUnref && a.ws._socket.unref(), a.onOpen() }, this.ws.onclose = this.onClose.bind( this ), this.ws.onmessage = function ( b ) { return a.onData( b.data ) }, this.ws.onerror = function ( b ) { return a.onError( "websocket error", b ) } } }, { key: "write", value: function ( a ) { var b = this; this.writable = !1; for ( var c = function ( c ) { var d = a[c], e = c === a.length - 1; da( d, b.supportsBinary, function ( a ) { try { Ha && b.ws.send( a ) } catch ( c ) { } e && Fa( function () { b.writable = !0, b.emit( "drain" ) }, b.setTimeoutFn ) } ) }, d = 0; d < a.length; d++ )c( d ) } }, { key: "doClose", value: function () { "undefined" != typeof this.ws && ( this.ws.close(), this.ws = null ) } }, { key: "uri", value: function () { var a = this.query || {}, b = this.opts.secure ? "wss" : "ws", c = ""; this.opts.port && ( "wss" === b && 443 !== Number( this.opts.port ) || "ws" === b && 80 !== Number( this.opts.port ) ) && ( c = ":" + this.opts.port ), this.opts.timestampRequests && ( a[this.opts.timestampParam] = ya() ), this.supportsBinary || ( a.b64 = 1 ); var d = za.encode( a ), e = -1 !== this.opts.hostname.indexOf( ":" ); return b + "://" + ( e ? "[" + this.opts.hostname + "]" : this.opts.hostname ) + c + this.opts.path + ( d.length ? "?" + d : "" ) } }, { key: "check", value: function () { return !( !Ga || "__initialize" in Ga && this.name === c.prototype.name ) } }] ), c }( sa ), La = { websocket: Ka, polling: Ca }, Ma = function ( c ) { function g ( c ) { var d, f = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}; return b( this, g ), d = h.call( this ), c && "object" === a( c ) && ( f = c, c = null ), c ? ( c = R( c ), f.hostname = c.host, f.secure = "https" === c.protocol || "wss" === c.protocol, f.port = c.port, c.query && ( f.query = c.query ) ) : f.host && ( f.hostname = R( f.host ).host ), w( j( d ), f ), d.secure = null != f.secure ? f.secure : "undefined" != typeof location && "https:" === location.protocol, f.hostname && !f.port && ( f.port = d.secure ? "443" : "80" ), d.hostname = f.hostname || ( "undefined" != typeof location ? location.hostname : "localhost" ), d.port = f.port || ( "undefined" != typeof location && location.port ? location.port : d.secure ? "443" : "80" ), d.transports = f.transports || ["polling", "websocket"], d.readyState = "", d.writeBuffer = [], d.prevBufferLen = 0, d.opts = e( { path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !0 }, f ), d.opts.path = d.opts.path.replace( /\/$/, "" ) + "/", "string" == typeof d.opts.query && ( d.opts.query = za.decode( d.opts.query ) ), d.id = null, d.upgrades = null, d.pingInterval = null, d.pingTimeout = null, d.pingTimeoutTimer = null, "function" == typeof addEventListener && ( d.opts.closeOnBeforeunload && addEventListener( "beforeunload", function () { d.transport && ( d.transport.removeAllListeners(), d.transport.close() ) }, !1 ), "localhost" !== d.hostname && ( d.offlineEventListener = function () { d.onClose( "transport close" ) }, addEventListener( "offline", d.offlineEventListener, !1 ) ) ), d.open(), d } f( g, c ); var h = l( g ); return d( g, [{ key: "createTransport", value: function ( a ) { var b = E( this.opts.query ); b.EIO = ra, b.transport = a, this.id && ( b.sid = this.id ); var c = e( {}, this.opts.transportOptions[a], this.opts, { query: b, socket: this, hostname: this.hostname, secure: this.secure, port: this.port } ); return new La[a]( c ) } }, { key: "open", value: function () { var a, b = this; if ( this.opts.rememberUpgrade && g.priorWebsocketSuccess && -1 !== this.transports.indexOf( "websocket" ) ) a = "websocket"; else { if ( 0 === this.transports.length ) return void this.setTimeoutFn( function () { b.emitReserved( "error", "No transports available" ) }, 0 ); a = this.transports[0] } this.readyState = "opening"; try { a = this.createTransport( a ) } catch ( c ) { return this.transports.shift(), void this.open() } a.open(), this.setTransport( a ) } }, { key: "setTransport", value: function ( a ) { var b = this; this.transport && this.transport.removeAllListeners(), this.transport = a, a.on( "drain", this.onDrain.bind( this ) ).on( "packet", this.onPacket.bind( this ) ).on( "error", this.onError.bind( this ) ).on( "close", function () { b.onClose( "transport close" ) } ) } }, { key: "probe", value: function ( a ) { function b () { i || ( i = !0, l(), h.close(), h = null ) } function c () { k( "transport closed" ) } function d () { k( "socket closed" ) } function e ( a ) { h && a.name !== h.name && b() } var f = this, h = this.createTransport( a ), i = !1; g.priorWebsocketSuccess = !1; var j = function () { i || ( h.send( [{ type: "ping", data: "probe" }] ), h.once( "packet", function ( a ) { if ( !i ) if ( "pong" === a.type && "probe" === a.data ) { if ( f.upgrading = !0, f.emitReserved( "upgrading", h ), !h ) return; g.priorWebsocketSuccess = "websocket" === h.name, f.transport.pause( function () { i || "closed" !== f.readyState && ( l(), f.setTransport( h ), h.send( [{ type: "upgrade" }] ), f.emitReserved( "upgrade", h ), h = null, f.upgrading = !1, f.flush() ) } ) } else { var b = new Error( "probe error" ); b.transport = h.name, f.emitReserved( "upgradeError", b ) } } ) ) }, k = function ( a ) { var c = new Error( "probe error: " + a ); c.transport = h.name, b(), f.emitReserved( "upgradeError", c ) }, l = function () { h.removeListener( "open", j ), h.removeListener( "error", k ), h.removeListener( "close", c ), f.off( "close", d ), f.off( "upgrading", e ) }; h.once( "open", j ), h.once( "error", k ), h.once( "close", c ), this.once( "close", d ), this.once( "upgrading", e ), h.open() } }, { key: "onOpen", value: function () { if ( this.readyState = "open", g.priorWebsocketSuccess = "websocket" === this.transport.name, this.emitReserved( "open" ), this.flush(), "open" === this.readyState && this.opts.upgrade && this.transport.pause ) for ( var a = 0, b = this.upgrades.length; b > a; a++ )this.probe( this.upgrades[a] ) } }, { key: "onPacket", value: function ( a ) { if ( "opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState ) switch ( this.emitReserved( "packet", a ), this.emitReserved( "heartbeat" ), a.type ) { case "open": this.onHandshake( JSON.parse( a.data ) ); break; case "ping": this.resetPingTimeout(), this.sendPacket( "pong" ), this.emitReserved( "ping" ), this.emitReserved( "pong" ); break; case "error": var b = new Error( "server error" ); b.code = a.data, this.onError( b ); break; case "message": this.emitReserved( "data", a.data ), this.emitReserved( "message", a.data ) } } }, { key: "onHandshake", value: function ( a ) { this.emitReserved( "handshake", a ), this.id = a.sid, this.transport.query.sid = a.sid, this.upgrades = this.filterUpgrades( a.upgrades ), this.pingInterval = a.pingInterval, this.pingTimeout = a.pingTimeout, this.onOpen(), "closed" !== this.readyState && this.resetPingTimeout() } }, { key: "resetPingTimeout", value: function () { var a = this; this.clearTimeoutFn( this.pingTimeoutTimer ), this.pingTimeoutTimer = this.setTimeoutFn( function () { a.onClose( "ping timeout" ) }, this.pingInterval + this.pingTimeout ), this.opts.autoUnref && this.pingTimeoutTimer.unref() } }, { key: "onDrain", value: function () { this.writeBuffer.splice( 0, this.prevBufferLen ), this.prevBufferLen = 0, 0 === this.writeBuffer.length ? this.emitReserved( "drain" ) : this.flush() } }, { key: "flush", value: function () { "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && ( this.transport.send( this.writeBuffer ), this.prevBufferLen = this.writeBuffer.length, this.emitReserved( "flush" ) ) } }, { key: "write", value: function ( a, b, c ) { return this.sendPacket( "message", a, b, c ), this } }, { key: "send", value: function ( a, b, c ) { return this.sendPacket( "message", a, b, c ), this } }, { key: "sendPacket", value: function ( a, b, c, d ) { if ( "function" == typeof b && ( d = b, b = void 0 ), "function" == typeof c && ( d = c, c = null ), "closing" !== this.readyState && "closed" !== this.readyState ) { c = c || {}, c.compress = !1 !== c.compress; var e = { type: a, data: b, options: c }; this.emitReserved( "packetCreate", e ), this.writeBuffer.push( e ), d && this.once( "flush", d ), this.flush() } } }, { key: "close", value: function i () { var a = this, i = function () { a.onClose( "forced close" ), a.transport.close() }, b = function d () { a.off( "upgrade", d ), a.off( "upgradeError", d ), i() }, c = function () { a.once( "upgrade", b ), a.once( "upgradeError", b ) }; return ( "opening" === this.readyState || "open" === this.readyState ) && ( this.readyState = "closing", this.writeBuffer.length ? this.once( "drain", function () { a.upgrading ? c() : i() } ) : this.upgrading ? c() : i() ), this } }, { key: "onError", value: function ( a ) { g.priorWebsocketSuccess = !1, this.emitReserved( "error", a ), this.onClose( "transport error", a ) } }, { key: "onClose", value: function ( a, b ) { ( "opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState ) && ( this.clearTimeoutFn( this.pingTimeoutTimer ), this.transport.removeAllListeners( "close" ), this.transport.close(), this.transport.removeAllListeners(), "function" == typeof removeEventListener && removeEventListener( "offline", this.offlineEventListener, !1 ), this.readyState = "closed", this.id = null, this.emitReserved( "close", a, b ), this.writeBuffer = [], this.prevBufferLen = 0 ) } }, { key: "filterUpgrades", value: function ( a ) { for ( var b = [], c = 0, d = a.length; d > c; c++ )~this.transports.indexOf( a[c] ) && b.push( a[c] ); return b } }] ), g }( Y ); Ma.protocol = ra; var Na, Oa = "function" == typeof ArrayBuffer, Pa = function ( a ) { return "function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView( a ) : a.buffer instanceof ArrayBuffer }, Qa = Object.prototype.toString, Ra = "function" == typeof Blob || "undefined" != typeof Blob && "[object BlobConstructor]" === Qa.call( Blob ), Sa = "function" == typeof File || "undefined" != typeof File && "[object FileConstructor]" === Qa.call( File ), Ta = 5; !function ( a ) { a[a.CONNECT = 0] = "CONNECT", a[a.DISCONNECT = 1] = "DISCONNECT", a[a.EVENT = 2] = "EVENT", a[a.ACK = 3] = "ACK", a[a.CONNECT_ERROR = 4] = "CONNECT_ERROR", a[a.BINARY_EVENT = 5] = "BINARY_EVENT", a[a.BINARY_ACK = 6] = "BINARY_ACK" }( Na || ( Na = {} ) ); var Ua = function () { function a () { b( this, a ) } return d( a, [{ key: "encode", value: function ( a ) { return a.type !== Na.EVENT && a.type !== Na.ACK || !G( a ) ? [this.encodeAsString( a )] : ( a.type = a.type === Na.EVENT ? Na.BINARY_EVENT : Na.BINARY_ACK, this.encodeAsBinary( a ) ) } }, { key: "encodeAsString", value: function ( a ) { var b = "" + a.type; return ( a.type === Na.BINARY_EVENT || a.type === Na.BINARY_ACK ) && ( b += a.attachments + "-" ), a.nsp && "/" !== a.nsp && ( b += a.nsp + "," ), null != a.id && ( b += a.id ), null != a.data && ( b += JSON.stringify( a.data ) ), b } }, { key: "encodeAsBinary", value: function ( a ) { var b = H( a ), c = this.encodeAsString( b.packet ), d = b.buffers; return d.unshift( c ), d } }] ), a }(), Va = function ( c ) { function e () { return b( this, e ), h.call( this ) } f( e, c ); var h = l( e ); return d( e, [{ key: "add", value: function ( a ) { var b; if ( "string" == typeof a ) b = this.decodeString( a ), b.type === Na.BINARY_EVENT || b.type === Na.BINARY_ACK ? ( this.reconstructor = new Wa( b ), 0 === b.attachments && n( g( e.prototype ), "emitReserved", this ).call( this, "decoded", b ) ) : n( g( e.prototype ), "emitReserved", this ).call( this, "decoded", b ); else { if ( !F( a ) && !a.base64 ) throw new Error( "Unknown type: " + a ); if ( !this.reconstructor ) throw new Error( "got binary data when not reconstructing a packet" ); b = this.reconstructor.takeBinaryData( a ), b && ( this.reconstructor = null, n( g( e.prototype ), "emitReserved", this ).call( this, "decoded", b ) ) } } }, { key: "decodeString", value: function ( a ) { var b = 0, c = { type: Number( a.charAt( 0 ) ) }; if ( void 0 === Na[c.type] ) throw new Error( "unknown packet type " + c.type ); if ( c.type === Na.BINARY_EVENT || c.type === Na.BINARY_ACK ) { for ( var d = b + 1; "-" !== a.charAt( ++b ) && b != a.length; ); var f = a.substring( d, b ); if ( f != Number( f ) || "-" !== a.charAt( b ) ) throw new Error( "Illegal attachments" ); c.attachments = Number( f ) } if ( "/" === a.charAt( b + 1 ) ) { for ( var g = b + 1; ++b; ) { var h = a.charAt( b ); if ( "," === h ) break; if ( b === a.length ) break } c.nsp = a.substring( g, b ) } else c.nsp = "/"; var i = a.charAt( b + 1 ); if ( "" !== i && Number( i ) == i ) { for ( var j = b + 1; ++b; ) { var k = a.charAt( b ); if ( null == k || Number( k ) != k ) { --b; break } if ( b === a.length ) break } c.id = Number( a.substring( j, b + 1 ) ) } if ( a.charAt( ++b ) ) { var l = L( a.substr( b ) ); if ( !e.isPayloadValid( c.type, l ) ) throw new Error( "invalid payload" ); c.data = l } return c } }, { key: "destroy", value: function () { this.reconstructor && this.reconstructor.finishedReconstruction() } }], [{ key: "isPayloadValid", value: function ( b, c ) { switch ( b ) { case Na.CONNECT: return "object" === a( c ); case Na.DISCONNECT: return void 0 === c; case Na.CONNECT_ERROR: return "string" == typeof c || "object" === a( c ); case Na.EVENT: case Na.BINARY_EVENT: return Array.isArray( c ) && c.length > 0; case Na.ACK: case Na.BINARY_ACK: return Array.isArray( c ) } } }] ), e }( Y ), Wa = function () { function a ( c ) { b( this, a ), this.packet = c, this.buffers = [], this.reconPack = c } return d( a, [{ key: "takeBinaryData", value: function ( a ) { if ( this.buffers.push( a ), this.buffers.length === this.reconPack.attachments ) { var b = J( this.reconPack, this.buffers ); return this.finishedReconstruction(), b } return null } }, { key: "finishedReconstruction", value: function () { this.reconPack = null, this.buffers = [] } }] ), a }(), Xa = Object.freeze( { __proto__: null, protocol: Ta, get PacketType () { return Na }, Encoder: Ua, Decoder: Va } ), Ya = Object.freeze( { connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 } ), Za = function ( a ) {
        function c ( a, d, f ) { var g; return b( this, c ), g = e.call( this ), g.connected = !1, g.disconnected = !0, g.receiveBuffer = [], g.sendBuffer = [], g.ids = 0, g.acks = {}, g.flags = {}, g.io = a, g.nsp = d, f && f.auth && ( g.auth = f.auth ), g.io._autoConnect && g.open(), g } f( c, a ); var e = l( c ); return d( c, [{ key: "subEvents", value: function () { if ( !this.subs ) { var a = this.io; this.subs = [M( a, "open", this.onopen.bind( this ) ), M( a, "packet", this.onpacket.bind( this ) ), M( a, "error", this.onerror.bind( this ) ), M( a, "close", this.onclose.bind( this ) )] } } }, { key: "active", get: function () { return !!this.subs } }, { key: "connect", value: function () { return this.connected ? this : ( this.subEvents(), this.io._reconnecting || this.io.open(), "open" === this.io._readyState && this.onopen(), this ) } }, { key: "open", value: function () { return this.connect() } }, { key: "send", value: function () { for ( var a = arguments.length, b = new Array( a ), c = 0; a > c; c++ )b[c] = arguments[c]; return b.unshift( "message" ), this.emit.apply( this, b ), this } }, {
            key: "emit", value: function ( a ) {
                if ( Ya.hasOwnProperty( a ) ) throw new Error( '"' + a + '" is a reserved event name' ); for ( var b = arguments.length, c = new Array( b > 1 ? b - 1 : 0 ), d = 1; b > d; d++ )c[d - 1] = arguments[d]; c.unshift( a ); var e = { type: Na.EVENT, data: c }; if ( e.options = {}, e.options.compress = this.flags.compress !== !1, "function" == typeof c[c.length - 1] ) { var f = this.ids++, g = c.pop(); this._registerAckCallback( f, g ), e.id = f } var h = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable, i = this.flags["volatile"] && ( !h || !this.connected ); return i || ( this.connected ? this.packet( e ) : this.sendBuffer.push( e ) ), this.flags = {}, this
            }
        }, { key: "_registerAckCallback", value: function ( a, b ) { var c = this, d = this.flags.timeout; if ( void 0 === d ) return void ( this.acks[a] = b ); var e = this.io.setTimeoutFn( function () { delete c.acks[a]; for ( var d = 0; d < c.sendBuffer.length; d++ )c.sendBuffer[d].id === a && c.sendBuffer.splice( d, 1 ); b.call( c, new Error( "operation has timed out" ) ) }, d ); this.acks[a] = function () { c.io.clearTimeoutFn( e ); for ( var a = arguments.length, d = new Array( a ), f = 0; a > f; f++ )d[f] = arguments[f]; b.apply( c, [null].concat( d ) ) } } }, { key: "packet", value: function ( a ) { a.nsp = this.nsp, this.io._packet( a ) } }, { key: "onopen", value: function () { var a = this; "function" == typeof this.auth ? this.auth( function ( b ) { a.packet( { type: Na.CONNECT, data: b } ) } ) : this.packet( { type: Na.CONNECT, data: this.auth } ) } }, { key: "onerror", value: function ( a ) { this.connected || this.emitReserved( "connect_error", a ) } }, { key: "onclose", value: function ( a ) { this.connected = !1, this.disconnected = !0, delete this.id, this.emitReserved( "disconnect", a ) } }, { key: "onpacket", value: function ( a ) { var b = a.nsp === this.nsp; if ( b ) switch ( a.type ) { case Na.CONNECT: if ( a.data && a.data.sid ) { var c = a.data.sid; this.onconnect( c ) } else this.emitReserved( "connect_error", new Error( "It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)" ) ); break; case Na.EVENT: this.onevent( a ); break; case Na.BINARY_EVENT: this.onevent( a ); break; case Na.ACK: this.onack( a ); break; case Na.BINARY_ACK: this.onack( a ); break; case Na.DISCONNECT: this.ondisconnect(); break; case Na.CONNECT_ERROR: this.destroy(); var d = new Error( a.data.message ); d.data = a.data.data, this.emitReserved( "connect_error", d ) } } }, { key: "onevent", value: function ( a ) { var b = a.data || []; null != a.id && b.push( this.ack( a.id ) ), this.connected ? this.emitEvent( b ) : this.receiveBuffer.push( Object.freeze( b ) ) } }, { key: "emitEvent", value: function ( a ) { if ( this._anyListeners && this._anyListeners.length ) { var b, d = this._anyListeners.slice(), e = q( d ); try { for ( e.s(); !( b = e.n() ).done; ) { var f = b.value; f.apply( this, a ) } } catch ( h ) { e.e( h ) } finally { e.f() } } n( g( c.prototype ), "emit", this ).apply( this, a ) } }, { key: "ack", value: function ( a ) { var b = this, c = !1; return function () { if ( !c ) { c = !0; for ( var d = arguments.length, e = new Array( d ), f = 0; d > f; f++ )e[f] = arguments[f]; b.packet( { type: Na.ACK, id: a, data: e } ) } } } }, { key: "onack", value: function ( a ) { var b = this.acks[a.id]; "function" == typeof b && ( b.apply( this, a.data ), delete this.acks[a.id] ) } }, { key: "onconnect", value: function ( a ) { this.id = a, this.connected = !0, this.disconnected = !1, this.emitBuffered(), this.emitReserved( "connect" ) } }, { key: "emitBuffered", value: function () { var a = this; this.receiveBuffer.forEach( function ( b ) { return a.emitEvent( b ) } ), this.receiveBuffer = [], this.sendBuffer.forEach( function ( b ) { return a.packet( b ) } ), this.sendBuffer = [] } }, { key: "ondisconnect", value: function () { this.destroy(), this.onclose( "io server disconnect" ) } }, { key: "destroy", value: function () { this.subs && ( this.subs.forEach( function ( a ) { return a() } ), this.subs = void 0 ), this.io._destroy( this ) } }, { key: "disconnect", value: function () { return this.connected && this.packet( { type: Na.DISCONNECT } ), this.destroy(), this.connected && this.onclose( "io client disconnect" ), this } }, { key: "close", value: function () { return this.disconnect() } }, { key: "compress", value: function ( a ) { return this.flags.compress = a, this } }, { key: "volatile", get: function () { return this.flags["volatile"] = !0, this } }, { key: "timeout", value: function ( a ) { return this.flags.timeout = a, this } }, { key: "onAny", value: function ( a ) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push( a ), this } }, { key: "prependAny", value: function ( a ) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift( a ), this } }, { key: "offAny", value: function ( a ) { if ( !this._anyListeners ) return this; if ( a ) { for ( var b = this._anyListeners, c = 0; c < b.length; c++ )if ( a === b[c] ) return b.splice( c, 1 ), this } else this._anyListeners = []; return this } }, { key: "listenersAny", value: function () { return this._anyListeners || [] } }] ), c
    }( Y ), $a = N; N.prototype.duration = function () { var a = this.ms * Math.pow( this.factor, this.attempts++ ); if ( this.jitter ) { var b = Math.random(), c = Math.floor( b * this.jitter * a ); a = 0 == ( 1 & Math.floor( 10 * b ) ) ? a - c : a + c } return 0 | Math.min( a, this.max ) }, N.prototype.reset = function () { this.attempts = 0 }, N.prototype.setMin = function ( a ) { this.ms = a }, N.prototype.setMax = function ( a ) { this.max = a }, N.prototype.setJitter = function ( a ) { this.jitter = a }; var _a = function ( c ) { function e ( c, d ) { var f; b( this, e ); var h; f = g.call( this ), f.nsps = {}, f.subs = [], c && "object" === a( c ) && ( d = c, c = void 0 ), d = d || {}, d.path = d.path || "/socket.io", f.opts = d, w( j( f ), d ), f.reconnection( d.reconnection !== !1 ), f.reconnectionAttempts( d.reconnectionAttempts || 1 / 0 ), f.reconnectionDelay( d.reconnectionDelay || 1e3 ), f.reconnectionDelayMax( d.reconnectionDelayMax || 5e3 ), f.randomizationFactor( null !== ( h = d.randomizationFactor ) && void 0 !== h ? h : .5 ), f.backoff = new $a( { min: f.reconnectionDelay(), max: f.reconnectionDelayMax(), jitter: f.randomizationFactor() } ), f.timeout( null == d.timeout ? 2e4 : d.timeout ), f._readyState = "closed", f.uri = c; var i = d.parser || Xa; return f.encoder = new i.Encoder, f.decoder = new i.Decoder, f._autoConnect = d.autoConnect !== !1, f._autoConnect && f.open(), f } f( e, c ); var g = l( e ); return d( e, [{ key: "reconnection", value: function ( a ) { return arguments.length ? ( this._reconnection = !!a, this ) : this._reconnection } }, { key: "reconnectionAttempts", value: function ( a ) { return void 0 === a ? this._reconnectionAttempts : ( this._reconnectionAttempts = a, this ) } }, { key: "reconnectionDelay", value: function ( a ) { var b; return void 0 === a ? this._reconnectionDelay : ( this._reconnectionDelay = a, null === ( b = this.backoff ) || void 0 === b ? void 0 : b.setMin( a ), this ) } }, { key: "randomizationFactor", value: function ( a ) { var b; return void 0 === a ? this._randomizationFactor : ( this._randomizationFactor = a, null === ( b = this.backoff ) || void 0 === b ? void 0 : b.setJitter( a ), this ) } }, { key: "reconnectionDelayMax", value: function ( a ) { var b; return void 0 === a ? this._reconnectionDelayMax : ( this._reconnectionDelayMax = a, null === ( b = this.backoff ) || void 0 === b ? void 0 : b.setMax( a ), this ) } }, { key: "timeout", value: function ( a ) { return arguments.length ? ( this._timeout = a, this ) : this._timeout } }, { key: "maybeReconnectOnOpen", value: function () { !this._reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect() } }, { key: "open", value: function ( a ) { var b = this; if ( ~this._readyState.indexOf( "open" ) ) return this; this.engine = new Ma( this.uri, this.opts ); var c = this.engine, d = this; this._readyState = "opening", this.skipReconnect = !1; var e = M( c, "open", function () { d.onopen(), a && a() } ), f = M( c, "error", function ( c ) { d.cleanup(), d._readyState = "closed", b.emitReserved( "error", c ), a ? a( c ) : d.maybeReconnectOnOpen() } ); if ( !1 !== this._timeout ) { var g = this._timeout; 0 === g && e(); var h = this.setTimeoutFn( function () { e(), c.close(), c.emit( "error", new Error( "timeout" ) ) }, g ); this.opts.autoUnref && h.unref(), this.subs.push( function () { clearTimeout( h ) } ) } return this.subs.push( e ), this.subs.push( f ), this } }, { key: "connect", value: function ( a ) { return this.open( a ) } }, { key: "onopen", value: function () { this.cleanup(), this._readyState = "open", this.emitReserved( "open" ); var a = this.engine; this.subs.push( M( a, "ping", this.onping.bind( this ) ), M( a, "data", this.ondata.bind( this ) ), M( a, "error", this.onerror.bind( this ) ), M( a, "close", this.onclose.bind( this ) ), M( this.decoder, "decoded", this.ondecoded.bind( this ) ) ) } }, { key: "onping", value: function () { this.emitReserved( "ping" ) } }, { key: "ondata", value: function ( a ) { this.decoder.add( a ) } }, { key: "ondecoded", value: function ( a ) { this.emitReserved( "packet", a ) } }, { key: "onerror", value: function ( a ) { this.emitReserved( "error", a ) } }, { key: "socket", value: function h ( a, b ) { var h = this.nsps[a]; return h || ( h = new Za( this, a, b ), this.nsps[a] = h ), h } }, { key: "_destroy", value: function ( a ) { for ( var b = Object.keys( this.nsps ), c = 0, d = b; c < d.length; c++ ) { var e = d[c], f = this.nsps[e]; if ( f.active ) return } this._close() } }, { key: "_packet", value: function ( a ) { for ( var b = this.encoder.encode( a ), c = 0; c < b.length; c++ )this.engine.write( b[c], a.options ) } }, { key: "cleanup", value: function () { this.subs.forEach( function ( a ) { return a() } ), this.subs.length = 0, this.decoder.destroy() } }, { key: "_close", value: function () { this.skipReconnect = !0, this._reconnecting = !1, this.onclose( "forced close" ), this.engine && this.engine.close() } }, { key: "disconnect", value: function () { return this._close() } }, { key: "onclose", value: function ( a ) { this.cleanup(), this.backoff.reset(), this._readyState = "closed", this.emitReserved( "close", a ), this._reconnection && !this.skipReconnect && this.reconnect() } }, { key: "reconnect", value: function () { var a = this; if ( this._reconnecting || this.skipReconnect ) return this; var b = this; if ( this.backoff.attempts >= this._reconnectionAttempts ) this.backoff.reset(), this.emitReserved( "reconnect_failed" ), this._reconnecting = !1; else { var c = this.backoff.duration(); this._reconnecting = !0; var d = this.setTimeoutFn( function () { b.skipReconnect || ( a.emitReserved( "reconnect_attempt", b.backoff.attempts ), b.skipReconnect || b.open( function ( c ) { c ? ( b._reconnecting = !1, b.reconnect(), a.emitReserved( "reconnect_error", c ) ) : b.onreconnect() } ) ) }, c ); this.opts.autoUnref && d.unref(), this.subs.push( function () { clearTimeout( d ) } ) } } }, { key: "onreconnect", value: function () { var a = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved( "reconnect", a ) } }] ), e }( Y ), ab = {}; return e( O, { Manager: _a, Socket: Za, io: O, connect: O } ), O
} ), window.CHUB = function () { var a = this; this.socket = {}, CHUB.prototype.start = function ( b ) { return b ? ( this.socket = io( "https://live.telecmi.com", { query: { token: b } } ), this.socket.on( "agents-list", function ( b ) { a.onAgents( b ) } ), this.socket.on( "call-feed", function ( b ) { a.onCalls( b ) } ), this.socket.on( "callback-list", function ( b ) { a.onCallback( b ) } ), this.socket.on( "cmi-status", function ( b ) { a.onStatus( b ) } ), this.socket.on( "live-call-feed", function ( b ) { a.onCount( b ) } ), this.socket.on( "agent-bridged", function ( b ) { a.onagentAnswer( b ) } ), void this.socket.on( "customer-bridged", function ( b ) { a.onAnswer( b ) } ) ) : void this.onStatus( { status: "error", msg: "Invalid token" } ) }, CHUB.prototype.subscribeAgents = function ( a ) { this.socket.emit( "subscribeadmin-agents-list", { inetno: a } ) }, CHUB.prototype.removeAllListeners = function ( a ) { this.socket.removeAllListeners() }, CHUB.prototype.callBarging = function ( a, b, c ) { return a ? void this.socket.emit( "admin-call-barging", { uuid: a, to: b, myid: c } ) : void this.onStatus( { status: "error", msg: "Invalid UUID" } ) }, CHUB.prototype.globalBarging = function ( a, b ) { return a ? void this.socket.emit( "admin-call-globalbarging", { uuid: a, to: b } ) : void this.onStatus( { status: "error", msg: "Invalid UUID" } ) }, CHUB.prototype.subscribeCalls = function ( a ) { this.socket.emit( "admin-get-feed", { inetno: a } ) }, CHUB.prototype.monitorCalls = function ( a ) { return a ? void this.socket.emit( "admin-call-feed", { inetno: a } ) : void this.onStatus( { status: "error", msg: "Invalid APP ID" } ) }, CHUB.prototype.onCalls = function ( a ) { }, CHUB.prototype.onAgents = function ( a ) { }, CHUB.prototype.onStatus = function ( a ) { }, CHUB.prototype.onCount = function ( a ) { }, CHUB.prototype.onagentAnswer = function ( a ) { }, CHUB.prototype.onAnswer = function ( a ) { }, CHUB.prototype.onCallback = function ( a ) { } };